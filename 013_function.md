好久沒有寫筆記了！

原因是...好久沒有繼續學習寫程式了！

希望這次可以堅持下去啊（？）

--
這篇筆記主要記錄的是關於 function （函數）

在此之前，我所學習到的東西基本上都是用一次叫一次，比方說，如果我想要算一個長為10，寬為5的長方形的面積，我可能就寫
```python
rectangle_area = 10*5
```

我如果要算另一個長為20，寬為5的長方形，那我就要另外再寫

```python
rectangle_area2 = 20*5
```


長方形這個例子看起來還好，但是有的時候，我想做的事情牽涉很多個推理步驟，如果我每次都要重新複製貼上一樣的程式碼，那我的程式就會變得又臭又長，而且很難重複使用

這個時候，把常常會用上的程式碼變成一個函數就會非常的有用！

假設我們有個函數做 rec_a ，也就是，算長方形的小程式，那我只要完整的寫一次長方形面積的計算過程，之後就只要打`rec_a`，並且輸入長與寬即可

實際的做法如下：
```python
def rec_a(length, width):
  area = length * width
  return area
```

這段程式碼的意思是這樣的：

我有一個函數，他的名字叫做rec_a
我定義（def）這個函數為一個需要`length`與`width`這兩種數值
（這邊的`length`與`width`是這個函數的參數（parameter）；實際在呼叫這個函數時輸入的值，如10, 5這兩個數字，叫做引數（argument））
我指定一個變數叫做`area`，我用這個變數儲存長乘上寬的數值
當整個程式執行完畢後，他會回傳（return）`area` 儲存的數值給我

有了這個函數之後，假若我想要算三個長方形長與寬分別為10與5, 100與20, 50與10的面積，我只要打上

```python
rec_a(10,5)
rec_a(100,20)
rec_a(50,10)
```

即可


這邊另外要注意的事情是，這個操作這個函數得到的結果是一個回傳給程式的值，這個函數執行的結果不包含「顯示」這個數值


所以，以第一個`rec_a(10,5)`為例
我們如果只有打`rec_a(10,5)`的話，我們是不會在螢幕上看到任何數值的

我們如果要看到50，要記得使用print，這樣才會把數值print出來

如：
```python

print(rec_a(10,5))
```

為什麼要特別強調函數回傳的是一個值，如果要看那個值的話要另外印出來呢？

這是因為，函數回傳的東西如果可以是一個數值的話，那就表示...我們可以在呼叫一次這個函數，讓這個函數以同樣的方式處理這個新的值！！




這邊就必須提到函數的另一個優點了，就是....函數可以很輕鬆的做出**遞迴**

好比說，假設我們今天想要判定一串有大中小括號的字串中的大中小括號的排列方式是不是合法的，也就是：

1) 每個大中小括號都是成雙成對，有一個左小括號就有一個右小括號，有一個左中括號就有一個右中括號，有一個左大括號就有一個右大括號
2) 這些括號排列的方式，必然可以找到左右成對，如“[]()”是一個合法的排列，“{()}"也是一個合法的排列

如果我們想要寫一個程式來判斷一串括號是否是以合法的方式排列，我們可以這麼想：

如果一串括號中的括號以()、[]、{}的形式出現，就是為是合法的，就先把他們拿掉，比方說，如果我們考慮的字串是長這個樣子：

```python
s = "([]{})"
```
在這個字串中，我們可以找到[]、{}，我們知道他們是合法的，就先把他們拿掉，剩下的就會是

```python
s= "()"
```

這個時候，我們再以同樣的邏輯做一次檢定，會發現這個字串會變成長度為零的字串，那我們就知道，這個字串是合法的

如果排列方式是不合法的，那不管我怎麼做，長度都不會變成零，那就是不合法的

這個「反覆」執行的一大特色在於，第二次再執行時，執行的對象是第一次執行的結果，倘若有第三第，那也是一樣的，第三次執行，是對第二次執行後產生的結果執行

每次呼叫，都是把新的狀態交給自己來處理，這種「自己呼叫自己並根據不同狀態處理」的結構，就是遞迴的本質

這個層層遞遞，就是遞迴的精神



按此精神，我們可以寫一個函數來判定任意括號字串是否以合法方式排列

```python

def isValid(s):
    if len(s) == 0: #如果字串長度為零，則為合法，回傳一個True
        return True
    
    ns = s.replace("()", "").replace("[]","").replace("{}", "") #這裡用到了字串的 .replace() 方法：把括號對 ("()", "[]", "{}") 找出來並換成空字串，相當於「刪掉」已經配對好的括號。


    if s == ns: #如果本來的字串跟新的字串長度是一樣的，那表示沒有任何取代發生，在長度依舊不為零的情況下，只有該字串的排列不合法的可能性了
        return False 
    
    else: #如果新的字串長度跟本來的長度不同，那就表示還有可能是合法的，我們先回傳isValid(ns）的結果，讓他繼續做下去，直到他最後得到True或False
        return isValid(ns)
```






